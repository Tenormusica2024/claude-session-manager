param(
    [string]$Command = "interactive",
    [switch]$NoAutoSummary  # Skip auto-summarization
)

# Session names database
$NamesFile = "$env:USERPROFILE\.claude\session-names.json"
$ProjectsDir = "$env:USERPROFILE\.claude\projects"
$ClaudeExe = "$env:USERPROFILE\.bun\bin\claude.exe"

# Global: Track duplicate files for cleanup
$script:duplicateFiles = @()

# Load session names (convert PSCustomObject to hashtable for dynamic property addition)
function Get-SessionNames {
    if (Test-Path $NamesFile) {
        try {
            $content = Get-Content $NamesFile -Raw -Encoding UTF8 -ErrorAction Stop
            $json = $content | ConvertFrom-Json -ErrorAction Stop

            # Convert sessions PSCustomObject to hashtable
            $sessionsHash = @{}
            if ($json.sessions) {
                $json.sessions.PSObject.Properties | ForEach-Object {
                    $sessionsHash[$_.Name] = @{
                        name = $_.Value.name
                        updatedAt = $_.Value.updatedAt
                        type = $_.Value.type
                    }
                }
            }
            return @{ sessions = $sessionsHash }
        }
        catch {
            return @{ sessions = @{} }
        }
    }
    return @{ sessions = @{} }
}

# Save session names
function Save-SessionNames {
    param($names)
    $names | ConvertTo-Json -Depth 10 | Set-Content $NamesFile -Encoding UTF8
}

# Get display name for session
function Get-SessionDisplayName {
    param($sessionId, $defaultSummary, $names)

    $sessionData = $names.sessions.$sessionId
    if ($sessionData -and $sessionData.name) {
        return $sessionData.name
    }
    return $defaultSummary
}

# Extract meaningful session title from conversation rallies (no API call - instant)
function Get-QuickTitle {
    param($filePath)

    # Read file with encoding fallback
    $allLines = $null
    try {
        $allLines = Get-Content $filePath -Encoding UTF8 -ErrorAction Stop
    }
    catch {
        try {
            $allLines = Get-Content $filePath -ErrorAction SilentlyContinue
        }
        catch { return $null }
    }
    if (-not $allLines -or $allLines.Count -eq 0) { return $null }

    # Helper: Check if text is meaningful as a title
    function Test-MeaningfulTitle {
        param($text)
        if (-not $text -or $text.Length -lt 8) { return $false }

        # Skip patterns - not meaningful as titles (English version)
        $skipPatterns = @(
            # Status/completion
            "^(Done|Fixed|Completed|OK|Sure|Yes|No|Got it|Thanks|Thank you|Confirmed|Acknowledged)",
            "^(Perfect|Great|Excellent|Awesome|Nice|Good|Right|Understood|Check|Report)",
            # Greetings/conversational
            "^(Hi|Hello|Hey|Yo|So|Well|Now|Alright|Let me|I'll|I will|I'm going to)",
            # System messages
            "^(Caveat|Generated by|Note:|Warning:|Error:|Info:|Debug:)",
            # Just emojis or markers
            "^[âœ…ðŸ“ŠðŸ”¥ðŸŽ¯ðŸ’¡ðŸš¨âš ï¸ðŸ‘ðŸ‘Ž]",
            # Just headers without context
            "^(Implemented|Installed|Completed|Review|Summary|Result|Test|Output)",
            # Dates/times only
            "^\d{4}-\d{2}-\d{2}",
            "^\d{1,2}/\d{1,2}/\d{4}",
            # Code/commands
            "^(```|import |const |var |let |function |class |def |npm |pip |git |cd |ls |mkdir |rm )",
            "^[A-Z_]+\s*=",  # ENV vars
            # File paths
            "^(C:\\|/Users/|~/|\./|http|https)",
            # Questions that are too generic
            "^(Is this|Does this|Can you|Could you|What do you think)$"
        )

        foreach ($pattern in $skipPatterns) {
            if ($text -match $pattern) { return $false }
        }

        # Skip if contains file extensions (likely a file reference)
        if ($text -match "\.(png|jpg|jpeg|gif|md|ps1|json|txt|ts|js|py|tsx|jsx|css|html)") { return $false }

        # Skip if garbled (>1/3 unusual chars for English)
        $cleanChars = ($text -replace "[a-zA-Z0-9\s\-\.\,\!\?\(\)\:\;\'\"]", "")
        if ($cleanChars.Length -gt ($text.Length / 3)) { return $false }

        # Skip if mostly punctuation/symbols
        if (($text -replace "[\w]", "").Length -gt ($text.Length / 2)) { return $false }

        return $true
    }

    # Helper: Extract clean text from message content
    function Get-CleanText {
        param($content)
        if (-not $content) { return $null }

        $text = $content -replace "`n", " " -replace "`r", "" -replace "\s+", " "
        $text = $text.Trim()

        # Remove markdown formatting
        $text = $text -replace '\*\*(.+?)\*\*', '$1'  # bold
        $text = $text -replace '```[\s\S]*?```', ''  # code blocks
        $text = $text -replace '^\s*[-*]\s*', ''  # list markers
        $text = $text -replace '^#+\s*', ''  # headers

        return $text.Trim()
    }

    # Collect all messages in order (newest first)
    $messages = @()
    foreach ($line in $allLines) {
        try {
            $entry = $line | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($entry.message -and $entry.message.role -and $entry.message.content) {
                $content = if ($entry.message.content -is [array]) {
                    ($entry.message.content | Where-Object { $_.type -eq "text" } | Select-Object -First 1).text
                } else { $entry.message.content }

                if ($content -and $content.Length -gt 5) {
                    $messages += @{
                        role = $entry.message.role
                        content = $content
                    }
                }
            }
        }
        catch { }
    }

    # Reverse to get newest first
    [array]::Reverse($messages)

    # Strategy 1: Look for topic description in recent USER messages
    # (What did the user ask for? That's usually the best title)
    $userCount = 0
    foreach ($msg in $messages) {
        if ($msg.role -ne "user") { continue }
        $userCount++
        if ($userCount -gt 15) { break }  # Check up to 15 recent user messages

        $text = Get-CleanText -content $msg.content

        # Take first meaningful sentence
        $sentences = $text -split "[ã€‚\.\!\?]" | Where-Object { $_.Trim().Length -gt 5 }
        foreach ($sentence in $sentences) {
            $sentence = $sentence.Trim()
            if ($sentence.Length -gt 50) {
                $sentence = $sentence.Substring(0, 50)
                $lastSpace = $sentence.LastIndexOf(" ")
                if ($lastSpace -gt 30) { $sentence = $sentence.Substring(0, $lastSpace) }
                $sentence = $sentence + "..."
            }

            if (Test-MeaningfulTitle -text $sentence) {
                return $sentence
            }
        }
    }

    # Strategy 2: Look for descriptive headers in assistant responses
    foreach ($msg in $messages) {
        if ($msg.role -ne "assistant") { continue }

        # Look for meaningful headers (## Something specific)
        if ($msg.content -match "##\s+([^#\n]+)") {
            $header = $matches[1].Trim()
            # Remove emojis from start
            $header = $header -replace "^[âœ…ðŸ“ŠðŸ”¥ðŸŽ¯ðŸ’¡ðŸš¨âš ï¸\s]+", ""
            if ($header.Length -gt 5 -and $header.Length -lt 50) {
                if (Test-MeaningfulTitle -text $header) {
                    return $header
                }
            }
        }
    }

    # Strategy 3: First user message as last resort
    foreach ($line in $allLines | Select-Object -First 20) {
        try {
            $entry = $line | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($entry.message -and $entry.message.role -eq "user" -and $entry.message.content) {
                $text = Get-CleanText -content $entry.message.content
                if ($text.Length -gt 40) {
                    $text = $text.Substring(0, 40) + "..."
                }
                if (Test-MeaningfulTitle -text $text) {
                    return $text
                }
            }
        }
        catch { }
    }

    return $null
}

# Generate AI summary for a session (used by manual S key only)
function Get-AISummaryQuiet {
    param($sessionId, $filePath)

    # Extract user messages
    $lines = Get-Content $filePath -TotalCount 50 -Encoding UTF8 -ErrorAction SilentlyContinue
    $userMessages = @()
    foreach ($line in $lines) {
        try {
            $entry = $line | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($entry.message -and $entry.message.role -eq "user" -and $entry.message.content) {
                $content = $entry.message.content
                if ($content -is [string] -and $content.Length -gt 0) {
                    $userMessages += $content
                }
            }
        }
        catch { }
    }

    if ($userMessages.Count -eq 0) {
        return $null
    }

    # Create prompt for summarization - strict title-only format
    $messagesText = ($userMessages | Select-Object -First 3) -join " | "
    if ($messagesText.Length -gt 500) {
        $messagesText = $messagesText.Substring(0, 500)
    }

    $prompt = "Create a short title (3-8 words) for this coding session. Output ONLY the title, nothing else. No quotes, no explanation. Example outputs: 'GitHub Actions CI setup' or 'React component refactoring' or 'Firebase auth implementation'. Session content: $messagesText"

    try {
        $env:ANTHROPIC_API_KEY = ""
        $result = & $ClaudeExe -p $prompt --model haiku --dangerously-skip-permissions 2>$null
        if ($result) {
            $summary = ($result -split "`n")[0].Trim().Trim('"').Trim("'")
            if ($summary.Length -gt 40) {
                $summary = $summary.Substring(0, 40)
            }
            if ($summary.Length -gt 5 -and -not ($summary -match "^(I |This |The |Here |Let me|Sorry)")) {
                return $summary
            }
        }
    }
    catch { }

    return $null
}

# Generate AI summary (verbose mode for manual trigger)
function Get-AISummary {
    param($sessionId, $filePath)

    Write-Host ""
    Write-Host "Generating AI summary (Haiku)..." -ForegroundColor Yellow

    $summary = Get-AISummaryQuiet -sessionId $sessionId -filePath $filePath

    if ($summary) {
        Write-Host "Summary: $summary" -ForegroundColor Green
    }
    else {
        Write-Host "Failed to generate summary" -ForegroundColor Red
    }

    return $summary
}

# Cleanup duplicate session files
function Remove-DuplicateFiles {
    param($duplicates)

    if ($duplicates.Count -eq 0) {
        Write-Host "No duplicate files to clean up." -ForegroundColor Yellow
        return 0
    }

    Write-Host ""
    Write-Host "Found $($duplicates.Count) duplicate files to remove:" -ForegroundColor Yellow
    foreach ($file in $duplicates) {
        Write-Host "  - $($file.Name) ($(($file.LastWriteTime).ToString('yyyy-MM-dd HH:mm')))" -ForegroundColor Gray
    }

    Write-Host ""
    Write-Host "Delete these files? [Y/N]: " -NoNewline -ForegroundColor Cyan
    $confirm = Read-Host

    if ($confirm -match "^[Yy]") {
        $deleted = 0
        foreach ($file in $duplicates) {
            try {
                Remove-Item $file.FullName -Force -ErrorAction Stop
                $deleted++
            }
            catch {
                Write-Host "  Failed to delete: $($file.Name)" -ForegroundColor Red
            }
        }
        Write-Host "Deleted $deleted files." -ForegroundColor Green
        return $deleted
    }
    else {
        Write-Host "Cancelled." -ForegroundColor Yellow
        return 0
    }
}

Write-Host "=== Claude Session Manager ===" -ForegroundColor Cyan

# Load names database
$sessionNames = Get-SessionNames

# Get sessions
Write-Host "Scanning sessions..."
$allSessions = @()

$projectDirs = Get-ChildItem -Path $ProjectsDir -Directory -ErrorAction SilentlyContinue
Write-Host "Found $($projectDirs.Count) project dirs"

foreach ($projectDir in $projectDirs) {
    $jsonFiles = Get-ChildItem -Path $projectDir.FullName -Filter "*.jsonl" -ErrorAction SilentlyContinue |
                 Sort-Object LastWriteTime -Descending

    foreach ($jsonFile in $jsonFiles) {
        try {
            $firstLine = Get-Content $jsonFile.FullName -TotalCount 1 -Encoding UTF8 -ErrorAction Stop
            if (-not $firstLine) { continue }

            $data = $firstLine | ConvertFrom-Json -ErrorAction Stop

            # Get session ID (from first line or filename for compacted sessions)
            $sessionId = $null
            if ($data.sessionId) {
                $sessionId = $data.sessionId
            } else {
                $sessionId = [System.IO.Path]::GetFileNameWithoutExtension($jsonFile.Name)
            }
            if (-not $sessionId) { continue }

            # Get default summary using smart extraction (newest messages first, skip NG words)
            $defaultSummary = Get-QuickTitle -filePath $jsonFile.FullName
            if (-not $defaultSummary) {
                # Fallback for compacted sessions with summary field
                if ($data.summary) {
                    $len = [Math]::Min(40, $data.summary.Length)
                    $defaultSummary = $data.summary.Substring(0, $len)
                } else {
                    $defaultSummary = "(no content)"
                }
            }

            # Skip warmup and empty sessions
            if ($defaultSummary -match "^(no content|Warmup|\(no content\))") {
                continue
            }

            # Get display name (custom name or default)
            $displayName = Get-SessionDisplayName -sessionId $sessionId -defaultSummary $defaultSummary -names $sessionNames

            # Check if has custom name
            $hasCustomName = $false
            if ($sessionNames.sessions.$sessionId -and $sessionNames.sessions.$sessionId.name) {
                $hasCustomName = $true
            }

            $allSessions += [PSCustomObject]@{
                SessionId = $sessionId
                Summary = $displayName
                DefaultSummary = $defaultSummary
                LastModified = $jsonFile.LastWriteTime
                HasCustomName = $hasCustomName
                FilePath = $jsonFile.FullName
                FileInfo = $jsonFile
            }
        }
        catch {
            # Skip errors
        }
    }
}

# Proper deduplication by SessionId - keep only the most recent
$grouped = $allSessions | Group-Object SessionId
$sessions = @()
$script:duplicateFiles = @()

foreach ($group in $grouped) {
    $sorted = $group.Group | Sort-Object LastModified -Descending
    # Keep the newest
    $sessions += $sorted[0]
    # Track older duplicates for potential cleanup
    if ($sorted.Count -gt 1) {
        $script:duplicateFiles += $sorted[1..($sorted.Count-1)] | ForEach-Object { $_.FileInfo }
    }
}

# Sort final list by LastModified
$sessions = $sessions | Sort-Object LastModified -Descending

$duplicateCount = $script:duplicateFiles.Count
if ($duplicateCount -gt 0) {
    Write-Host "Found $($sessions.Count) unique sessions ($duplicateCount duplicates detected)" -ForegroundColor Green
}
else {
    Write-Host "Found $($sessions.Count) sessions" -ForegroundColor Green
}

# Note: Auto-titling disabled for fast startup
# Stop hook handles automatic naming after each response
# Use S key to manually summarize unnamed sessions

if ($Command -eq "interactive" -and $sessions.Count -gt 0) {
    $selectedIndex = 0
    $maxDisplay = [Math]::Min(15, $sessions.Count)

    while ($true) {
        Clear-Host
        Write-Host "=== Claude Session Manager ===" -ForegroundColor Cyan
        if ($script:duplicateFiles.Count -gt 0) {
            Write-Host "($($script:duplicateFiles.Count) duplicate files - press D to clean up)" -ForegroundColor DarkYellow
        }
        Write-Host ""

        for ($i = 0; $i -lt $maxDisplay; $i++) {
            $session = $sessions[$i]
            $marker = if ($i -eq $selectedIndex) { "> " } else { "  " }
            $color = if ($i -eq $selectedIndex) { "Green" } else { "White" }

            # Add star for custom named sessions
            $star = if ($session.HasCustomName) { "*" } else { " " }

            $display = "$marker$star[$($i+1)] $($session.Summary)"
            if ($display.Length -gt 70) { $display = $display.Substring(0, 70) + "..." }

            Write-Host $display -ForegroundColor $color
        }

        Write-Host ""
        $helpText = "[Up/Down] Move  [Enter] Resume  [S] Re-summarize  [N] Name"
        if ($script:duplicateFiles.Count -gt 0) {
            $helpText += "  [D] Clean duplicates"
        }
        $helpText += "  [Q] Quit"
        Write-Host $helpText -ForegroundColor Gray

        $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

        switch ($key.VirtualKeyCode) {
            38 { if ($selectedIndex -gt 0) { $selectedIndex-- } }  # Up
            40 { if ($selectedIndex -lt $maxDisplay - 1) { $selectedIndex++ } }  # Down
            13 {  # Enter - Resume
                $selected = $sessions[$selectedIndex]
                Write-Host ""
                Write-Host "Resuming session: $($selected.SessionId)" -ForegroundColor Green
                & $ClaudeExe -r $selected.SessionId
                return
            }
            83 {  # S - Re-summarize
                $selected = $sessions[$selectedIndex]
                $summary = Get-AISummary -sessionId $selected.SessionId -filePath $selected.FilePath
                if ($summary) {
                    if (-not $sessionNames.sessions) {
                        $sessionNames.sessions = @{}
                    }
                    $sessionNames.sessions.($selected.SessionId) = @{
                        name = $summary
                        updatedAt = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss")
                        type = "ai"
                    }
                    Save-SessionNames -names $sessionNames
                    $sessions[$selectedIndex].Summary = $summary
                    $sessions[$selectedIndex].HasCustomName = $true
                    Write-Host "Saved! Press any key..." -ForegroundColor Green
                    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                }
                else {
                    Write-Host "Press any key to continue..." -ForegroundColor Yellow
                    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                }
            }
            78 {  # N - Manual Name
                $selected = $sessions[$selectedIndex]
                Write-Host ""
                Write-Host "Current: $($selected.Summary)" -ForegroundColor Yellow
                Write-Host "Enter new name (empty to cancel): " -NoNewline -ForegroundColor Cyan
                $newName = Read-Host

                if ($newName -and $newName.Trim().Length -gt 0) {
                    $newName = $newName.Trim()
                    if ($newName.Length -gt 50) {
                        $newName = $newName.Substring(0, 50)
                    }
                    if (-not $sessionNames.sessions) {
                        $sessionNames.sessions = @{}
                    }
                    $sessionNames.sessions.($selected.SessionId) = @{
                        name = $newName
                        updatedAt = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss")
                        type = "manual"
                    }
                    Save-SessionNames -names $sessionNames
                    $sessions[$selectedIndex].Summary = $newName
                    $sessions[$selectedIndex].HasCustomName = $true
                    Write-Host "Saved!" -ForegroundColor Green
                    Start-Sleep -Milliseconds 500
                }
            }
            68 {  # D - Clean duplicates
                if ($script:duplicateFiles.Count -gt 0) {
                    $deleted = Remove-DuplicateFiles -duplicates $script:duplicateFiles
                    if ($deleted -gt 0) {
                        $script:duplicateFiles = @()
                    }
                    Write-Host "Press any key to continue..." -ForegroundColor Gray
                    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                }
            }
            81 { return }  # Q
            default {
                $char = $key.Character.ToString().ToLower()
                if ($char -eq 'q') { return }
                if ($char -eq 'd' -and $script:duplicateFiles.Count -gt 0) {
                    $deleted = Remove-DuplicateFiles -duplicates $script:duplicateFiles
                    if ($deleted -gt 0) {
                        $script:duplicateFiles = @()
                    }
                    Write-Host "Press any key to continue..." -ForegroundColor Gray
                    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                }
                if ($char -eq 's') {
                    $selected = $sessions[$selectedIndex]
                    $summary = Get-AISummary -sessionId $selected.SessionId -filePath $selected.FilePath
                    if ($summary) {
                        if (-not $sessionNames.sessions) {
                            $sessionNames.sessions = @{}
                        }
                        $sessionNames.sessions.($selected.SessionId) = @{
                            name = $summary
                            updatedAt = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss")
                            type = "ai"
                        }
                        Save-SessionNames -names $sessionNames
                        $sessions[$selectedIndex].Summary = $summary
                        $sessions[$selectedIndex].HasCustomName = $true
                        Write-Host "Saved! Press any key..." -ForegroundColor Green
                        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                    }
                    else {
                        Write-Host "Press any key to continue..." -ForegroundColor Yellow
                        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
                    }
                }
                if ($char -eq 'n') {
                    $selected = $sessions[$selectedIndex]
                    Write-Host ""
                    Write-Host "Current: $($selected.Summary)" -ForegroundColor Yellow
                    Write-Host "Enter new name (empty to cancel): " -NoNewline -ForegroundColor Cyan
                    $newName = Read-Host

                    if ($newName -and $newName.Trim().Length -gt 0) {
                        $newName = $newName.Trim()
                        if ($newName.Length -gt 50) {
                            $newName = $newName.Substring(0, 50)
                        }
                        if (-not $sessionNames.sessions) {
                            $sessionNames.sessions = @{}
                        }
                        $sessionNames.sessions.($selected.SessionId) = @{
                            name = $newName
                            updatedAt = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss")
                            type = "manual"
                        }
                        Save-SessionNames -names $sessionNames
                        $sessions[$selectedIndex].Summary = $newName
                        $sessions[$selectedIndex].HasCustomName = $true
                        Write-Host "Saved!" -ForegroundColor Green
                        Start-Sleep -Milliseconds 500
                    }
                }
            }
        }
    }
}
elseif ($Command -eq "list") {
    Write-Host ""
    $sessions | Select-Object -First 20 | ForEach-Object {
        $star = if ($_.HasCustomName) { "*" } else { " " }
        Write-Host " $star$($_.SessionId.Substring(0,8))... | $($_.Summary)"
    }
}
