# Claude Session Manager - Interactive Resume
# /resume‰∏ä‰Ωç‰∫íÊèõ: „É™„Çπ„ÉàË°®Á§∫ ‚Üí Êï∞Â≠ó„Ç≠„Éº„ÅßÂç≥ÊôÇ„Çª„ÉÉ„Ç∑„Éß„É≥ÂÜçÈñã

param(
    [int]$MaxDisplay = 15
)

# Settings
$ProjectsDir = "$env:USERPROFILE\.claude\projects"
$TitleCachePath = "$env:USERPROFILE\.claude\session-titles-cache.json"
$NamesFile = "$env:USERPROFILE\.claude\session-names.json"

# Find claude.exe
function Find-ClaudeExe {
    $candidates = @(
        "$env:USERPROFILE\.bun\bin\claude.exe",
        "$env:USERPROFILE\.claude\local\claude.exe",
        "$env:APPDATA\npm\claude.cmd",
        "$env:LOCALAPPDATA\Programs\claude\claude.exe"
    )
    foreach ($path in $candidates) {
        if (Test-Path $path) { return $path }
    }
    $whereResult = Get-Command "claude" -ErrorAction SilentlyContinue
    if ($whereResult) { return $whereResult.Source }
    return $null
}

# Quick title extraction (no API)
function Get-QuickTitle {
    param($filePath)

    try {
        $firstLines = Get-Content $filePath -TotalCount 30 -Encoding UTF8 -ErrorAction SilentlyContinue
        $fileInfo = Get-Item $filePath -ErrorAction SilentlyContinue

        if ($fileInfo.Length -gt 50KB) {
            $stream = [System.IO.File]::Open($filePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
            $seekPos = [Math]::Max(0, $stream.Length - 50KB)
            $stream.Seek($seekPos, [System.IO.SeekOrigin]::Begin) | Out-Null
            $reader = New-Object System.IO.StreamReader($stream, [System.Text.Encoding]::UTF8)
            $tailContent = $reader.ReadToEnd()
            $reader.Close()
            $stream.Close()
            $lastLines = ($tailContent -split "`n") | Select-Object -Last 50
        } else {
            $lastLines = $firstLines
        }
    }
    catch {
        $firstLines = @()
        $lastLines = @()
    }

    $allLines = @($firstLines) + @($lastLines) | Select-Object -First 50

    # Extract meaningful title from user messages
    $skipPatterns = @(
        "^(ÂÆå‰∫Ü|‰∫ÜËß£|ÊâøÁü•|„ÅØ„ÅÑ|OK|„Åä„Å£„Åë|Â†±Âëä|Á¢∫Ë™ç|‰øÆÊ≠£|ÂØæÂøú|ÂÆüË°å|„ÉÜ„Çπ„ÉàÂÆå‰∫Ü|„ÉÅ„Çß„ÉÉ„ÇØ)",
        "^(Done|Fixed|Completed|OK|Sure|Yes|No|Got it|Thanks|Thank you)",
        "^(Hi|Hello|„Åù„ÅÜ„Å†„Å≠|„Å™„Çã„Åª„Å©|„ÅÑ„ÅÑ„Å≠|„ÅÇ„Çä„Åå„Å®|„ÅäÁñ≤„Çå|„Çà„Åó|„Åß„ÅØ|test|„ÉÜ„Çπ„Éà$)",
        "^(Caveat|Generated by|Note:|Warning:|Error:)",
        "(Base directory|this skill|GitHub Issue|Â†±Âëä„Åó„Åæ„Åó„Åü|Â†±Âëä„Åó„Åü„Çà|Â†±ÂëäÂÆå‰∫Ü)",
        "^(Create a short title|„Åì„ÅÆ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çª„ÉÉ„Ç∑„Éß„É≥)",
        "(Summarize this Claude Code session|5-10 words)",
        "^https?://",
        "^[‚úÖüìäüî•üéØüí°üö®‚ö†Ô∏è]"
    )

    foreach ($line in $allLines) {
        try {
            $entry = $line | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($entry.message -and $entry.message.role -eq "user" -and $entry.message.content) {
                $content = if ($entry.message.content -is [array]) {
                    ($entry.message.content | Where-Object { $_.type -eq "text" } | Select-Object -First 1).text
                } else { $entry.message.content }

                if ($content -and $content.Length -gt 5) {
                    $text = $content -replace "`n", " " -replace "\s+", " ").Trim()
                    if ($text.Length -gt 55) { $text = $text.Substring(0, 55) + "..." }

                    $skip = $false
                    foreach ($pattern in $skipPatterns) {
                        if ($text -match $pattern) { $skip = $true; break }
                    }
                    if (-not $skip) { return $text }
                }
            }
        }
        catch { }
    }

    return "(no title)"
}

# Main
Write-Host ""
Write-Host "=== Claude Session Manager ===" -ForegroundColor Cyan
Write-Host ""

# Load cache
$titleCache = @{}
if (Test-Path $TitleCachePath) {
    try {
        $titleCache = Get-Content $TitleCachePath -Raw -Encoding UTF8 | ConvertFrom-Json -AsHashtable
    } catch { }
}

# Load custom names
$sessionNames = @{}
if (Test-Path $NamesFile) {
    try {
        $content = Get-Content $NamesFile -Raw -Encoding UTF8
        $json = $content | ConvertFrom-Json
        if ($json.sessions) {
            $json.sessions.PSObject.Properties | ForEach-Object {
                if ($_.Value.type -ne "ai-hook") {
                    $sessionNames[$_.Name] = $_.Value.name
                }
            }
        }
    } catch { }
}

# Scan sessions
$sessions = @()
$projectDirs = Get-ChildItem -Path $ProjectsDir -Directory -ErrorAction SilentlyContinue

foreach ($projectDir in $projectDirs) {
    # Skip AI skill directories
    if ($projectDir.Name -match "(ai-buzz-extractor|claude-skills-test|note-auto-article)") { continue }

    $jsonFiles = Get-ChildItem -Path $projectDir.FullName -Filter "*.jsonl" -ErrorAction SilentlyContinue |
                 Sort-Object LastWriteTime -Descending

    foreach ($jsonFile in $jsonFiles) {
        # Skip small files
        if ($jsonFile.Length -lt 5000) { continue }

        try {
            $firstLine = Get-Content $jsonFile.FullName -TotalCount 1 -Encoding UTF8 -ErrorAction SilentlyContinue
            if (-not $firstLine) { continue }

            $data = $firstLine | ConvertFrom-Json -ErrorAction SilentlyContinue
            if (-not $data) { continue }

            # Skip system files
            if ($data.type -eq "system" -and $data.subtype -eq "compact_boundary") { continue }

            $sessionId = if ($data.sessionId) { $data.sessionId } else { [System.IO.Path]::GetFileNameWithoutExtension($jsonFile.Name) }
            if (-not $sessionId) { continue }

            # Get title (custom name > cached title > quick title)
            $title = $null
            if ($sessionNames.ContainsKey($sessionId)) {
                $title = $sessionNames[$sessionId]
            } elseif ($titleCache.ContainsKey($sessionId) -and $titleCache[$sessionId] -ne "SKIP") {
                $title = $titleCache[$sessionId]
            } else {
                $title = Get-QuickTitle -filePath $jsonFile.FullName
            }

            # Skip garbage titles
            if ($title -match "^(no content|Warmup|\(no content\)|Create a short title|„Åì„ÅÆ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çª„ÉÉ„Ç∑„Éß„É≥)") { continue }
            if ($title -match "ÂåªNÁπß|Á∏∫Ëñô„ÉªÁπß|ÁπßÔΩ≥ÁπùÔΩºÁπù|ÈÉ¢ÔΩß„ÉªÔΩ≥|ÈÇµÔΩ∫ÈòÆ") { continue }

            $sessions += [PSCustomObject]@{
                Index = $sessions.Count
                SessionId = $sessionId
                Title = $title
                FilePath = $jsonFile.FullName
                LastModified = $jsonFile.LastWriteTime
            }
        }
        catch { }
    }
}

# Deduplicate by SessionId (keep newest)
$grouped = $sessions | Group-Object SessionId
$uniqueSessions = @()
foreach ($group in $grouped) {
    $sorted = $group.Group | Sort-Object LastModified -Descending
    $uniqueSessions += $sorted[0]
}

# Sort by last modified and limit
$uniqueSessions = $uniqueSessions | Sort-Object LastModified -Descending | Select-Object -First $MaxDisplay

# Display list
Write-Host "Recent Sessions (most recent first):" -ForegroundColor Gray
Write-Host ""

for ($i = 0; $i -lt $uniqueSessions.Count; $i++) {
    $session = $uniqueSessions[$i]
    $num = ($i + 1).ToString().PadLeft(2)
    $display = " [$num] $($session.Title)"
    if ($display.Length -gt 70) { $display = $display.Substring(0, 70) + "..." }
    Write-Host $display
}

Write-Host ""

# If no sessions, exit
if ($uniqueSessions.Count -eq 0) {
    Write-Host "No sessions found." -ForegroundColor Yellow
    exit 0
}

# Prompt for selection
Write-Host "Select a session to resume (1-$($uniqueSessions.Count)), or press Enter to cancel:" -ForegroundColor Cyan -NoNewline
$input = Read-Host

# Validate input
if ([string]::IsNullOrWhiteSpace($input)) {
    Write-Host "Cancelled." -ForegroundColor Gray
    exit 0
}

$selection = 0
if (-not [int]::TryParse($input, [ref]$selection)) {
    Write-Host "Invalid input. Please enter a number." -ForegroundColor Red
    exit 1
}

if ($selection -lt 1 -or $selection -gt $uniqueSessions.Count) {
    Write-Host "Invalid selection. Please enter a number between 1 and $($uniqueSessions.Count)." -ForegroundColor Red
    exit 1
}

# Get selected session
$selectedSession = $uniqueSessions[$selection - 1]

# Find claude.exe
$claudeExe = Find-ClaudeExe
if (-not $claudeExe) {
    Write-Host "ERROR: claude.exe not found." -ForegroundColor Red
    exit 1
}

# Resume session
Write-Host ""
Write-Host "Resuming session: $($selectedSession.Title)" -ForegroundColor Green
Write-Host "Session ID: $($selectedSession.SessionId)" -ForegroundColor Gray
Write-Host ""

# Execute claude -r
$process = Start-Process -FilePath $claudeExe -ArgumentList "-r", $selectedSession.SessionId -NoNewWindow -PassThru
Wait-Process -InputObject $process -Timeout 300

exit $LASTEXITCODE
